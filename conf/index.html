<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrueNAS Installer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap" />
</head>

<body class="bg-gray-100 min-h-screen">
    <div id="app"></div>

    <script>
        let showLoader = true;
        let loaderState = 'loading';
        let statusMessage = 'Connecting...';

        function updateUI() {
            const app = document.getElementById('app');
            
            if (showLoader) {
                app.innerHTML = `
                    <div class="fixed inset-0 flex items-center justify-center bg-white bg-opacity-80 z-50">
                        <div class="text-center">
                            ${loaderState === 'loading' ? 
                                '<div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>' : ''}
                            ${loaderState === 'success' ? 
                                '<div class="inline-block"><span class="material-symbols-outlined text-6xl text-green-500">check_circle</span></div>' : ''}
                            ${loaderState === 'error' ? 
                                '<div class="inline-block"><span class="material-symbols-outlined text-6xl text-red-500">cancel</span></div>' : ''}
                            <p class="mt-4 text-gray-700 font-medium text-2xl">${statusMessage}</p>
                        </div>
                    </div>
                `;
            } else {
                app.innerHTML = '';
            }
        }

        function setShowLoader(value) {
            showLoader = value;
            updateUI();
        }

        function setLoaderState(value) {
            loaderState = value;
            updateUI();
        }

        function setStatusMessage(value) {
            statusMessage = value;
            updateUI();
        }

        class RPCClient {
            constructor(url, config) {
                this.url = url;
                this.config = config;
                this.pendingRequests = new Map();
                this.pingInterval = null;
                this.retryCount = 0;
                this.maxRetries = 5;
                this.retryIntervals = this.generateRetryIntervals();
                this.retryTimeout = null;
                this.connect();
            }

            generateRetryIntervals() {
                // Generate intervals: 2, 4, 8, 16, then cap at 20 for remaining retries
                const intervals = [];
                for (let i = 0; i < this.maxRetries; i++) {
                    if (i < 4) {
                        intervals.push(Math.pow(2, i + 1) * 1000); // 2, 4, 8, 16 seconds
                    } else {
                        intervals.push(20000); // Cap at 20 seconds
                    }
                }
                return intervals;
            }

            connect() {
                this.ws = new WebSocket(this.url);
                this.setupEventHandlers();
            }

            setupEventHandlers() {
                this.ws.onopen = (event) => {
                    setStatusMessage('Websocket is connected');
                    this.retryCount = 0; // Reset retry count on successful connection
                    this.startPing();
                    this.onConnected();
                };

                this.ws.onmessage = (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        this.handleResponse(response);
                    } catch (error) {
                        setStatusMessage('Failed to parse response');
                    }
                };

                this.ws.onclose = (event) => {
                    this.stopPing();
                    if (this.retryCount < this.maxRetries) {
                        this.scheduleRetry();
                    } else {
                        setShowLoader(true);
                        setStatusMessage('Websocket connection failed after 5 retries');
                        setLoaderState('error');
                    }
                };

                this.ws.onerror = (error) => {
                    setStatusMessage('WebSocket connection failed');
                    setLoaderState('error');
                };
            }

            call(method, params = []) {
                return new Promise((resolve, reject) => {
                    const id = this.generateUUID();
                    const request = {
                        id,
                        jsonrpc: '2.0',
                        method,
                        params
                    };

                    this.pendingRequests.set(id, { resolve, reject });
                    this.ws.send(JSON.stringify(request));
                });
            }

            handleResponse(response) {
                if (response.id && this.pendingRequests.has(response.id)) {
                    const { resolve, reject } = this.pendingRequests.get(response.id);
                    this.pendingRequests.delete(response.id);
                    if (response.error) {
                        reject(response.error);
                    } else {
                        resolve(response.result);
                    }
                } else if (response.method) {
                    this.handleEvent(response);
                }
            }

            handleEvent(event) {
                switch (event.method) {
                    case 'installation_progress':
                        this.onInstallationProgress(event.params[0]);
                        break;
                    default:
                        console.error('Unhandled event:', event);
                }
            }

            onInstallationProgress(data) {
                const { progress, message } = data;
                const percentage = Math.round(progress * 100);
                setStatusMessage(`${message} (${percentage}%)`);
                setLoaderState('loading');
                setShowLoader(true);
            }

            startPing() {
                this.pingInterval = setInterval(() => {
                    this.ping();
                }, 30000);
            }

            stopPing() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }

            scheduleRetry() {
                this.retryCount++;
                const currentInterval = this.retryIntervals[Math.min(this.retryCount - 1, this.retryIntervals.length - 1)];
                const seconds = currentInterval / 1000;
                setStatusMessage(`Connection lost. Retrying in ${seconds} seconds... (${this.retryCount}/${this.maxRetries})`);
                setLoaderState('loading');
                setShowLoader(true);
                
                this.retryTimeout = setTimeout(() => {
                    console.log(`Attempting reconnection ${this.retryCount}/${this.maxRetries}`);
                    this.connect();
                }, currentInterval);
            }

            cleanup() {
                this.stopPing();
                if (this.retryTimeout) {
                    clearTimeout(this.retryTimeout);
                    this.retryTimeout = null;
                }
            }

            async ping() {
                try {
                    await this.call('system_info');
                } catch (error) {
                    console.error('Ping failed:', error);
                }
            }

            async onConnected() {
                 try {
                    let accessKey = ''
                    setStatusMessage('Getting things ready...');
                    const isAdopted = await this.call('is_adopted');
                    if (!isAdopted) {
                        accessKey = await this.call('adopt');
                        localStorage.setItem('accessKey', accessKey);
                    } else {
                        accessKey = localStorage.getItem('accessKey');
                    }

                    await this.call('authenticate', accessKey)
                    let systemInfo = await this.call('system_info')
                    if (systemInfo.installation_running) {
                        setStatusMessage('Installation in progress');
                        return;
                    }
                    let tncConfig = await this.call('tnc_config')
                    if (Object.keys(tncConfig.registration_details).length) {
                        setStatusMessage('Please continue the setup in TNC UI');
                        return
                    }
                    
                    if (!tncConfig.enabled) {
                        if (!(this.config && this.config.account_service_base_url && this.config.leca_service_base_url && this.config.heartbeat_service_base_url && this.config.tnc_base_url)) {
                            setStatusMessage('Something is missing in the web address');
                            setLoaderState('error');
                        }
                        tncConfig = await this.call('configure_tnc', [{ ...this.config, enabled: true }]);
                    }
                    setStatusMessage('Generating TNC Registration URL');
                    const urlResult = await this.call('tnc_registration_uri');
                    setStatusMessage('The TNC registration URL is ready');
                    window.location.replace(`${urlResult}&installer_token=${accessKey}`)
                } catch (error) {
                    console.error(error)
                    setLoaderState('error');
                    setStatusMessage('Generating TNC Registration URL failed');
                }
            }

            generateUUID() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }

                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            updateUI();
            
            const urlParams = new URLSearchParams(window.location.search);
            const configParam = urlParams.get('config');
            try {
                const config = JSON.parse(decodeURIComponent(configParam));

                new RPCClient('ws://truenas-installer.local:8080/ws', config);
            } catch (error) {
                setStatusMessage('Invalid URL');
                setLoaderState('error');   
            }
        });
    </script>
</body>

</html>